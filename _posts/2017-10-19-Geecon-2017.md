---
layout: post
title: "Geecon 2017"
date: 2017-10-17
---

#  Making It Count: Quality is Not Optional

Quality is cross cutting non functional requirement.
Make explicit to agree with customer criticality.
Take pride, ownership and responsibility for the project to encourage quality.
Make people accountable.
Establish naming.
Spefication and docs are valuable.
Early analyse requirements.
Rise above implementation details and languages.


# Reactive Programming

Reactive is non blocking event driven appsthat scale with small number of threads with backpressure as key ingredient that aims to ensure producers do not overhelm consumers.

Back pressure: consumers can prevent getting overwhelmed.

## Main Abstractions
Publisher<T>:
Subscriber<T>:
Subscription:
Processor<T, R>:

## Reactive Core:
- fully non blockingfoundation. Interacts with Java 8 functional API
- Completable Future, Stream, Duration

## Spring Initializr
- generator for spring boot.
- allows generation of Kotlin

## Spring Boot:
- is convention vs configuration. (opinionated)

## Demo: Stream Movies
### Dependencies
- Reactive Web: Defaults to Netty server
- Reactive MongoDB: NoSQL, non blocking
- Lombok

### Reactive Service

```
@SpringBootApplication
class Application {

  @Bean
  CommandLineRunner demoData (MovieRepo repo) {
    return args -> {
      repo.deleteAll().thenMany(  // insteadof .block()
          Flux
            .just("Silence of lambdas", "enter the void", "Blade Reactor")
            .map(title -> new Movie(title))
            .flatMap(m-> repo.save(m))
            subscribe(Sys.out::println)
           )
    }
  }


  @Bean
  RouterFunction<ServerResopnse> routerFunction
    RounterFunctions.route(Req\\Predicates.gET("movies")
      Mono<ServerResponse>handle ServerRequest req

  @Bean
  RouterFunction(movieHandler)
    route(gET("movies"), movieHandler::all
    route(GET...
    route(
}

@Component
MovieHandler
  movieServ

  all
    ServerResponse.ok()..body(movieServ.getAll(), Movie.class)
  byId
    ...
  events
    ...


@Service
class MovieService {
  MovieRepo repo

  MovieServ(repo)
    repo = repo

  Flux<Movie> getAllMovies{
    repo.findAll
  }

  Mono<Movie> getMovieById(id)
    repo.findById(id)

  Flux<MovieEvent> getEvents(id)
    Flux.generate(sink -> sink.next(new MovieEvent(id, new Date())))
      .delayElements(Duration.ofSeconds(1))
}

@RunWithSpingRunner
@SpringBootTest
MovieServiceTest
  MovieServ movieServ

  getEvenetsTake10
    id = serv.getAll.blockFirst.getId
    StepVerifier.withVirtualTime(() -> movieServ
      .getEvents(id)
      .take(10))
      .collectList()
      .thenAwait(10 hours)
      .assertNexxt(list -> assertTrue(list.size == 10)
      .verifyComplete

@RestController
@ReqeuestMapping "movies"
class MovieController
  movieServ

  @GetMapping
  Flux<Movie>all

  @GetM ${id}
  Mono<movie> byId(id)
    serv.getbyid id

  @GetM
    type = TEXT_EVENT_STREAM
    path = ${id}/events
  Flux<Event> events(id)
    serv.getevents id


@Document // For Spring Data
@Data // Lombok
@RequiredArgsConstructor
class Movie {
  @Id id
  @NonNull titile
}
}

@Data @NoArgsConst @AllArgsConstructor
class MovieEvent {
  movieId
  when
}

interface MovieRespository extends ReactiveCrudRepository

```


### Reactive Client

```

@SBApp
Client
  @Bean
  WebClient client
   WebClient.create("localhost:8080/movies")

  @Bean
  CommandLineRunner demo(WebClient cllient)
    args -> client.get()
      .retrive
      .bodyToFlux(Movie.class)
      .filter(m -> m.getTitle.equalsIgnoroeCase("blade reactor"
      .flatMap(m -> client.get.uri("", m.getId).


MovieEvent
  id, when

Movie
  id, title
```

## Refs
reactive-streams.org
projectreacotr.io
github.com/mkheck/flux-flix-intro
github.com/joshlong/flux-flix-service



# Java EE 8 Release

## History
Started in 2014
Community surevey driven focus in 2016.
Focus: Web, json, injection, servlet, jsf, json p, security, validation

## Content

Modernize and simplify.
Enhance cdi, web and security

### json-p 1.1
Stamdard api to parse, generate, transform, query json
Update to lateest standarts: pinter, patch, merge patch
Add editing,...

#### Json pointer
string based syntax to id specific value
- tokens separated by/
- eg: /event/location
```
pt = Json.createPointer("/1/venue")
pt.getValue(jsonEvents)
pt.replace(jsonEvents, Jon.createValue(...))
```

#### Json Patch
- modify parts of json doc
- Below replaces at given path to given value.
```
[ { op: replace, path: /o/venue, value: Moscone West } ]
```

```
Json.createPatch
patch.apply(json)
Json.createPatchBuilder
```


#### Json Merge Patch
similar to patch. Those to be changed need to listed in the merge patch. Others will be lets untouched.
```
{a: va} + {b: vb} => {a: va, b:vb}
```

```
createMergeDiff
```

#### Json Collectors, Misc
iterate over json with collections
skipArray, skipObject

### Json Binding
similar to jaxb
standard api for existing framework e.g. genson, gson

JsonbBuilder: entry point to JSON Binding api
JsonB: fromJson, toJson

Default mapping: covers basic well known types
Customizations: rich, ignorinng, null handling, instatntion, visibility, formatting
Adapters n (De)Serializations can be implemented
```new JsonbConfig().withFormatting(true).withAdapters(new CarAdapter)```

### jax-rs

- async invoker, fluent api,

### Serve-Sent Event
Browser receives auto updates from server via http.
Not supported by IE.


### Servlet
- http 2 (reduce latency, paralllel)
- server push
- jsf 2.3: server push, cdi integration, web socket, ajax


### CDI
- split into core, java se, java ee
- async events, observer ordering

### Bean Validation
- date/time api, collection, optional, repetable annotations, new constraints
```@Past Year startYear```
```List<@Valid Customer>```

### Security API
- id store: storage sys, validates credentials, used by auth mechanism
- auth mech: simplify app accessible auth mech
```
@WebServlet(...
@ServletSecurity(@Http
```
- sec context: standardize

### Maintanance Release
- JPA: streams, date-time,

### Next?
- java ee to eclipse foundation

### Q & A

