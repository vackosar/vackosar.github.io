---
layout: post
title: "Geecon 2017"
date: 2017-10-17
---

#  Making It Count: Quality is Not Optional

Quality is cross cutting non functional requirement.
Make explicit to agree with customer criticality.
Take pride, ownership and responsibility for the project to encourage quality.
Make people accountable.
Establish naming.
Spefication and docs are valuable.
Early analyse requirements.
Rise above implementation details and languages.


# Reactive Programming

Reactive is non blocking event driven appsthat scale with small number of threads with backpressure as key ingredient that aims to ensure producers do not overhelm consumers.

Back pressure: consumers can prevent getting overwhelmed.

## Main Abstractions
Publisher<T>:
Subscriber<T>:
Subscription:
Processor<T, R>:

## Reactive Core:
- fully non blockingfoundation. Interacts with Java 8 functional API
- Completable Future, Stream, Duration

## Spring Initializr
- generator for spring boot.
- allows generation of Kotlin

## Spring Boot:
- is convention vs configuration. (opinionated)

## Demo: Stream Movies
### Dependencies
- Reactive Web: Defaults to Netty server
- Reactive MongoDB: NoSQL, non blocking
- Lombok

### Reactive Service

```
@SpringBootApplication
class Application {

  @Bean
  CommandLineRunner demoData (MovieRepo repo) {
    return args -> {
      repo.deleteAll().thenMany(  // insteadof .block()
          Flux
            .just("Silence of lambdas", "enter the void", "Blade Reactor")
            .map(title -> new Movie(title))
            .flatMap(m-> repo.save(m))
            subscribe(Sys.out::println)
           )
    }
  }


  @Bean
  RouterFunction<ServerResopnse> routerFunction
    RounterFunctions.route(Req\\Predicates.gET("movies")
      Mono<ServerResponse>handle ServerRequest req

  @Bean
  RouterFunction(movieHandler)
    route(gET("movies"), movieHandler::all
    route(GET...
    route(
}

@Component
MovieHandler
  movieServ

  all
    ServerResponse.ok()..body(movieServ.getAll(), Movie.class)
  byId
    ...
  events
    ...


@Service
class MovieService {
  MovieRepo repo

  MovieServ(repo)
    repo = repo

  Flux<Movie> getAllMovies{
    repo.findAll
  }

  Mono<Movie> getMovieById(id)
    repo.findById(id)

  Flux<MovieEvent> getEvents(id)
    Flux.generate(sink -> sink.next(new MovieEvent(id, new Date())))
      .delayElements(Duration.ofSeconds(1))
}

@RunWithSpingRunner
@SpringBootTest
MovieServiceTest
  MovieServ movieServ

  getEvenetsTake10
    id = serv.getAll.blockFirst.getId
    StepVerifier.withVirtualTime(() -> movieServ
      .getEvents(id)
      .take(10))
      .collectList()
      .thenAwait(10 hours)
      .assertNexxt(list -> assertTrue(list.size == 10)
      .verifyComplete

@RestController
@ReqeuestMapping "movies"
class MovieController
  movieServ

  @GetMapping
  Flux<Movie>all

  @GetM ${id}
  Mono<movie> byId(id)
    serv.getbyid id

  @GetM
    type = TEXT_EVENT_STREAM
    path = ${id}/events
  Flux<Event> events(id)
    serv.getevents id


@Document // For Spring Data
@Data // Lombok
@RequiredArgsConstructor
class Movie {
  @Id id
  @NonNull titile
}
}

@Data @NoArgsConst @AllArgsConstructor
class MovieEvent {
  movieId
  when
}

interface MovieRespository extends ReactiveCrudRepository

```


### Reactive Client

```

@SBApp
Client
  @Bean
  WebClient client
   WebClient.create("localhost:8080/movies")

  @Bean
  CommandLineRunner demo(WebClient cllient)
    args -> client.get()
      .retrive
      .bodyToFlux(Movie.class)
      .filter(m -> m.getTitle.equalsIgnoroeCase("blade reactor"
      .flatMap(m -> client.get.uri("", m.getId).


MovieEvent
  id, when

Movie
  id, title
```

## Refs
reactive-streams.org
projectreacotr.io
github.com/mkheck/flux-flix-intro
github.com/joshlong/flux-flix-service



# Java EE 8 Release

## History
Started in 2014
Community surevey driven focus in 2016.
Focus: Web, json, injection, servlet, jsf, json p, security, validation

## Content

Modernize and simplify.
Enhance cdi, web and security

### json-p 1.1
Stamdard api to parse, generate, transform, query json
Update to lateest standarts: pinter, patch, merge patch
Add editing,...

#### Json pointer
string based syntax to id specific value
- tokens separated by/
- eg: /event/location
```
pt = Json.createPointer("/1/venue")
pt.getValue(jsonEvents)
pt.replace(jsonEvents, Jon.createValue(...))
```

#### Json Patch
- modify parts of json doc
- Below replaces at given path to given value.
```
[ { op: replace, path: /o/venue, value: Moscone West } ]
```

```
Json.createPatch
patch.apply(json)
Json.createPatchBuilder
```


#### Json Merge Patch
similar to patch. Those to be changed need to listed in the merge patch. Others will be lets untouched.
```
{a: va} + {b: vb} => {a: va, b:vb}
```

```
createMergeDiff
```

#### Json Collectors, Misc
iterate over json with collections
skipArray, skipObject

### Json Binding
similar to jaxb
standard api for existing framework e.g. genson, gson

JsonbBuilder: entry point to JSON Binding api
JsonB: fromJson, toJson

Default mapping: covers basic well known types
Customizations: rich, ignorinng, null handling, instatntion, visibility, formatting
Adapters n (De)Serializations can be implemented
```new JsonbConfig().withFormatting(true).withAdapters(new CarAdapter)```

### jax-rs

- async invoker, fluent api,

### Serve-Sent Event
Browser receives auto updates from server via http.
Not supported by IE.


### Servlet
- http 2 (reduce latency, paralllel)
- server push
- jsf 2.3: server push, cdi integration, web socket, ajax


### CDI
- split into core, java se, java ee
- async events, observer ordering

### Bean Validation
- date/time api, collection, optional, repetable annotations, new constraints
```@Past Year startYear```
```List<@Valid Customer>```

### Security API
- id store: storage sys, validates credentials, used by auth mechanism
- auth mech: simplify app accessible auth mech
```
@WebServlet(...
@ServletSecurity(@Http
```
- sec context: standardize

### Maintanance Release
- JPA: streams, date-time,

### Next?
- java ee to eclipse foundation

### Q & A


# Deep dive and learn about your OS

Namespaces: Used by containers
Linux capability: limiting accesses of executables
Docker uses inherently linux. Docker on Win uses virtualization or something thinner to run Docker.
Docker container is just a process on given linux.

## Container isolation have side effect.
- The process is not truely isolated e.g. number of files to open is limited by parent.
- Container simulates running as pid 1.
- Containers still do not contain kernel. We expect that all kernels are the same, even they are not.
- Security issues are bigger than on VMs as shared kernel is still exposed.

## VT-X

Deved by Intel. Simulates separation using hardware cpu context switching. Other hardware like network cards are being switched or emulated.


## Performance
Virtualization is not slow. People think that the virtualization is slow because because their experience with VirtualBox running full operating system.
Issue there is that graphical card has to be emulated, which is slow.

Input and output is generally slow on virtualization, but CPU is very fast.

## Virtualizaton Isolation
Virtualizattoin offers a lot more isolation. No ability to see other process, no shared limits. Much more security. Performance can be comparable if IO is controlled.

## Alpine Linux

## End Notes

Containers are not like VM. They have very limited isolation. Be aware.
Understand the OS.
Read on systemd.
Coupon geeconPRG16.
Be careful about OS upgrades.
Database on containers is bad idea.
Use linux everyday. Use Arch linux to learn by fixing it. ExHerbo distro very good to learn by much more breaking.
Read Linux newsletter LWN.
Read book OReilly Linux Kernel.
Clever-Cloud.com